CREATE OR REPLACE PROCEDURE 
ALLINEA_PERIODI_FAMILIARI(PROGIRIS                  IN  NUMBER                ,     -- progressivo del dipendente
                         NORD                       IN  NUMBER                ,     -- numero d'ordine del familiare
                         ERRORE                     OUT VARCHAR2) AS                -- eventuale errore occorso
-- Questa procedura richiamata per ogni dipendente verifica se i dati del periodo successivo
-- sono uguali a quelli del precedente unificando in questo caso i due periodi
  CURSOR C1 IS SELECT COLUMN_NAME NOMEDATO FROM COLS WHERE TABLE_NAME = 'SG101_FAMILIARI'
    AND COLUMN_NAME NOT IN ('DECORRENZA','DECORRENZA_FINE');
  CURSORE_DINAMICO_SG101 INTEGER;
  CURS_SG101 INTEGER;
  dDECORRENZA DATE;
  DECORRENZA DATE;
  DECORRENZA_FINE DATE;
  DECORRENZA_FINE_PREC DATE;
  ULTIMADECORRENZA_FINE DATE;
  NROWID VARCHAR2(20);
  NROWIDUPDATE VARCHAR2(20);
  NROWIDLOCK VARCHAR2(20);
  ESPRESSIONE VARCHAR2(32767);
  VALOREDATI1 VARCHAR2(10000);
  VALOREDATIOLD VARCHAR2(10000);
BEGIN
  -- Allineo i dati anagrafici(non storici) dei familiari: Cognome, Nome, Sesso, Comune di nascita e 
  -- Codice fiscale all'ultimo periodo storico, a parità di data di nascita.
  UPDATE SG101_FAMILIARI SG101 SET COGNOME = (SELECT COGNOME FROM SG101_FAMILIARI SG101A
    WHERE SG101A.PROGRESSIVO = SG101.PROGRESSIVO AND SG101A.NUMORD = SG101.NUMORD
    AND SG101A.DATANAS = SG101.DATANAS AND SG101A.DECORRENZA_FINE = TO_DATE('31123999','DDMMYYYY'))
    WHERE SG101.PROGRESSIVO = PROGIRIS AND SG101.NUMORD = NORD AND SG101.DECORRENZA_FINE < TO_DATE('31123999','DDMMYYYY');
  UPDATE SG101_FAMILIARI SG101 SET NOME = (SELECT NOME FROM SG101_FAMILIARI SG101A
    WHERE SG101A.PROGRESSIVO = SG101.PROGRESSIVO AND SG101A.NUMORD = SG101.NUMORD
    AND SG101A.DATANAS = SG101.DATANAS AND SG101A.DECORRENZA_FINE = TO_DATE('31123999','DDMMYYYY'))
    WHERE SG101.PROGRESSIVO = PROGIRIS AND SG101.NUMORD = NORD AND SG101.DECORRENZA_FINE < TO_DATE('31123999','DDMMYYYY');
  UPDATE SG101_FAMILIARI SG101 SET SESSO = (SELECT SESSO FROM SG101_FAMILIARI SG101A
    WHERE SG101A.PROGRESSIVO = SG101.PROGRESSIVO AND SG101A.NUMORD = SG101.NUMORD
    AND SG101A.DATANAS = SG101.DATANAS AND SG101A.DECORRENZA_FINE = TO_DATE('31123999','DDMMYYYY'))
    WHERE SG101.PROGRESSIVO = PROGIRIS AND SG101.NUMORD = NORD AND SG101.DECORRENZA_FINE < TO_DATE('31123999','DDMMYYYY');
  UPDATE SG101_FAMILIARI SG101 SET COMNAS = (SELECT COMNAS FROM SG101_FAMILIARI SG101A
    WHERE SG101A.PROGRESSIVO = SG101.PROGRESSIVO AND SG101A.NUMORD = SG101.NUMORD
    AND SG101A.DATANAS = SG101.DATANAS AND SG101A.DECORRENZA_FINE = TO_DATE('31123999','DDMMYYYY'))
    WHERE SG101.PROGRESSIVO = PROGIRIS AND SG101.NUMORD = NORD AND SG101.DECORRENZA_FINE < TO_DATE('31123999','DDMMYYYY');
  UPDATE SG101_FAMILIARI SG101 SET CODFISCALE = (SELECT CODFISCALE FROM SG101_FAMILIARI SG101A
    WHERE SG101A.PROGRESSIVO = SG101.PROGRESSIVO AND SG101A.NUMORD = SG101.NUMORD
    AND SG101A.DATANAS = SG101.DATANAS AND SG101A.DECORRENZA_FINE = TO_DATE('31123999','DDMMYYYY'))
    WHERE SG101.PROGRESSIVO = PROGIRIS AND SG101.NUMORD = NORD AND SG101.DECORRENZA_FINE < TO_DATE('31123999','DDMMYYYY');
  -- Imposto condizione di non errore nella varibile di output
  ERRORE:='';
  -- Concateno tutte le colonne di SG101_FAMILIARI tranne decorrenza e decorrenza_fine
  ESPRESSIONE:=''' ''';
  FOR T1 IN C1 LOOP
    IF ESPRESSIONE = ''' ''' THEN
      ESPRESSIONE:=T1.NOMEDATO;
    ELSE
      ESPRESSIONE:=ESPRESSIONE || ' || ' || T1.NOMEDATO;
    END IF;
  END LOOP;
  -- eseguo selezione di SG101_FAMILIARI concatenando tutti i campi tranne decorrenza e decorrenza_fine
  ESPRESSIONE:='SELECT ROWID, DECORRENZA, DECORRENZA_FINE, ' || ESPRESSIONE ||
    ' FROM SG101_FAMILIARI WHERE PROGRESSIVO = :PROGIRIS AND NUMORD =:NORD ORDER BY DECORRENZA';
  -- cursore che legge i periodi storici
  CURSORE_DINAMICO_SG101:=DBMS_SQL.OPEN_CURSOR;
  BEGIN--CURSORE_DINAMICO_SG101
  DBMS_SQL.PARSE(CURSORE_DINAMICO_SG101,ESPRESSIONE,DBMS_SQL.NATIVE);
  DBMS_SQL.DEFINE_COLUMN(CURSORE_DINAMICO_SG101,1,NROWID,20);
  DBMS_SQL.DEFINE_COLUMN(CURSORE_DINAMICO_SG101,2,DECORRENZA);
  DBMS_SQL.DEFINE_COLUMN(CURSORE_DINAMICO_SG101,3,DECORRENZA_FINE);
  DBMS_SQL.DEFINE_COLUMN(CURSORE_DINAMICO_SG101,4,VALOREDATI1,10000);
  DBMS_SQL.BIND_VARIABLE(CURSORE_DINAMICO_SG101, 'PROGIRIS', PROGIRIS);
  DBMS_SQL.BIND_VARIABLE(CURSORE_DINAMICO_SG101, 'NORD', NORD);
  CURS_SG101:=DBMS_SQL.EXECUTE(CURSORE_DINAMICO_SG101);
  NROWIDUPDATE:='';
  VALOREDATIOLD:='';
  ULTIMADECORRENZA_FINE:=NULL;
  DECORRENZA_FINE_PREC:=NULL;
  LOOP
    -- scorrimento sui record dei periodi storici
    IF DBMS_SQL.FETCH_ROWS(CURSORE_DINAMICO_SG101)>0 THEN
      DBMS_SQL.COLUMN_VALUE(CURSORE_DINAMICO_SG101, 1, NROWID);
      DBMS_SQL.COLUMN_VALUE(CURSORE_DINAMICO_SG101, 2, DECORRENZA);
      DBMS_SQL.COLUMN_VALUE(CURSORE_DINAMICO_SG101, 3, DECORRENZA_FINE);
      DBMS_SQL.COLUMN_VALUE(CURSORE_DINAMICO_SG101, 4, VALOREDATI1);
      -- se non e' stata fatta ancora nessuna lettura precedente
      BEGIN
        NROWIDLOCK:='';
        SELECT ROWID INTO NROWIDLOCK FROM SG101_FAMILIARI WHERE ROWID = NROWID  FOR UPDATE OF PROGRESSIVO,NUMORD
          NOWAIT;
      EXCEPTION
        WHEN OTHERS THEN
          -- Imposto condizione di errore per dipendente occupato
          ERRORE:='OC';
          ROLLBACK;
          DBMS_SQL.CLOSE_CURSOR(CURSORE_DINAMICO_SG101);
          GOTO FINE_AGGIORNAMENTO;
      END;
      IF (DECORRENZA_FINE_PREC IS NOT NULL) AND (DECORRENZA <> DECORRENZA_FINE_PREC + 1) THEN
        UPDATE SG101_FAMILIARI SET DECORRENZA = DECORRENZA_FINE_PREC + 1 WHERE ROWID = NROWID;
      END IF;
      DECORRENZA_FINE_PREC:=DECORRENZA_FINE;
      IF VALOREDATIOLD IS NULL THEN
        -- memorizzo dati da confrontare e rowid del periodo storico di cui aggiornare DECORRENZA_FINE
        VALOREDATIOLD:=VALOREDATI1;
        NROWIDUPDATE:=NROWID;
      ELSE
        IF VALOREDATI1 = VALOREDATIOLD THEN
          -- memorizzo la data di fine che servira' per aggiornare il primo periodo
          -- storico precedente con i dati uguali
          ULTIMADECORRENZA_FINE:=DECORRENZA_FINE;
          -- cancello il periodo storico con dati uguali al precedente
          DELETE SG101_FAMILIARI WHERE ROWID = NROWID;
        ELSE
          IF ULTIMADECORRENZA_FINE IS NOT NULL THEN
            -- se esiste un record precedente con dati uguali aggiorno la data fine
            UPDATE SG101_FAMILIARI SET DECORRENZA_FINE = ULTIMADECORRENZA_FINE WHERE ROWID = NROWIDUPDATE;
            ULTIMADECORRENZA_FINE:=NULL;
          END IF;
          -- salvo il valore dei dati letti per nuovo confronto
          VALOREDATIOLD:=VALOREDATI1;
          -- reimposto il rowid che sara' eventualmente da updatare
          NROWIDUPDATE:=NROWID;
        END IF;
      END IF;
    ELSE
      EXIT;
    END IF;
  END LOOP;
  EXCEPTION
    WHEN OTHERS THEN NULL;
  END; --CURSORE_DINAMICO_SG101
  DBMS_SQL.CLOSE_CURSOR(CURSORE_DINAMICO_SG101);
  IF ULTIMADECORRENZA_FINE IS NOT NULL THEN
    -- se esiste un record precedente con dati uguali aggiorno la data fine
    UPDATE SG101_FAMILIARI SET DECORRENZA_FINE = ULTIMADECORRENZA_FINE WHERE ROWID = NROWIDUPDATE;
  END IF;
  UPDATE SG101_FAMILIARI SET DECORRENZA_FINE = TO_DATE('31123999','DDMMYYYY') WHERE
    PROGRESSIVO = PROGIRIS AND NUMORD = NORD AND DECORRENZA = (SELECT MAX(DECORRENZA)
    FROM SG101_FAMILIARI WHERE PROGRESSIVO = PROGIRIS AND NUMORD = NORD);
  -- Su SG101_FAMILIARI la prima decorrenza viene comunque sempre anticipata al primo del mese
--  SELECT MIN(DECORRENZA) INTO dDECORRENZA FROM SG101_FAMILIARI WHERE PROGRESSIVO = PROGIRIS AND NUMORD = NORD;
--  UPDATE SG101_FAMILIARI SG101 SET DECORRENZA = TO_DATE('01'||TO_CHAR(dDECORRENZA,'MMYYYY'),'DDMMYYYY')
--    WHERE SG101.PROGRESSIVO = PROGIRIS AND SG101.NUMORD = NORD AND SG101.DECORRENZA =
--    (SELECT MIN(DECORRENZA) FROM SG101_FAMILIARI WHERE PROGRESSIVO = SG101.PROGRESSIVO AND NUMORD = SG101.NUMORD);
  COMMIT;
<<FINE_AGGIORNAMENTO>>
  NULL;
END;
/
